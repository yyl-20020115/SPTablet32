/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <intrin.h>

//-------------------------------------------------------------------------
// Function declarations

void start();
int write_mcr_1011_and_delay();
unsigned __int8 read_mcr();
char read_data_sp();
char read_data();
char set_interrupt();
unsigned __int8 do_handshake();
void parse_arguments();

//-------------------------------------------------------------------------
// Data declarations

char choice = '\0'; // weak
int port = 1016; // weak
char as_mouse = '\x01'; // weak
char as_emulation = '\0'; // weak
int args = 128; // weak
const CHAR aTitle[] = "SPTablet32"; // idb
const CHAR  aParameterError; // weak
const CHAR aTabletIsNotRes = 'T'; // idb
const CHAR  aNotSpTablet[] = ""; // weak
const CHAR aSetTabletModeO = 'S'; // idb
const CHAR  aResetTabletOk[] = ""; // weak
const CHAR aTabletConnectT = 'T'; // idb
const CHAR  aTabletConnectT_0[] = ""; // weak
const CHAR aSptabletCanUse[350] = "SPTablet      can use following command.\r\n  /?          This message.\r\n  /x          x = 1 or 2 to setup COM1 or COM2.\r\n  /E          Set Emulation On. SP345 will emulate MM9601,\r\n                                SP66 will emulate MM1212. \r\n  /M          Set Emulation Microsoft Mouse On.\r\n              If no /M this will set to MM series tablet.\r\n$"; // weak


//----- (00401080) --------------------------------------------------------
void start()
{
  int v0; // eax
  char v1; // cf
  int v2; // ecx
  char v3; // zf
  char v4; // al
  unsigned __int8 v5; // al
  const CHAR *v6; // edx
  const CHAR *v7; // edx
  int v8; // [esp-4h] [ebp-4h]

  choice = -1;
  while ( 1 )
  {
    parse_arguments();
    if ( v1 )
      break;
    switch ( (BYTE)v0 )
    {
      case 0x31:
        choice = 0;
        port = 1016;
        break;
      case 0x32:
        choice = 0;
        port = 760;
        break;
      case 0x45:
        as_emulation = 1;
        break;
      case 0x3F:
        v7 = aSptabletCanUse;
        goto LABEL_50;
      case 0x4D:
        as_mouse = 0;
        break;
      default:
        goto LABEL_4;
    }
  }
  if ( v0 != -1 )
  {
    while ( 1 )
    {
      if ( !(read_mcr() & 3) )
      {
        write_mcr_1011_and_delay();
        delay_ms(27);
      }
      do_handshake();
      set_interrupt();
      write_data(0);
      delay_ms(4);
      v2 = 2;
      do
      {
        v8 = v2;
        write_data(0x3Fu);
        v4 = read_data_sp();
        if ( !v1 )
        {
          if ( v4 == 4 )
          {
            if ( as_mouse == 1 )
            {
              if ( as_emulation == 1 )
              {
                write_data(0x4Fu);
                v5 = 98;
              }
              else
              {
                write_data(0x58u);
                v5 = 111;
              }
            }
            else
            {
              v5 = 75;
            }
          }
          else if ( v4 == 3 )
          {
            if ( as_mouse == 1 )
              v5 = 0;
            else
              v5 = 75;
          }
          else
          {
            if ( v4 != 6 )
            {
              if ( v4 != 2 && v4 != 8 )
              {
                v7 = (const CHAR *)&aNotSpTablet;
                goto LABEL_50;
              }
LABEL_42:
              if ( as_mouse == 1 )
              {
                MessageBoxA(0, &aSetTabletModeO, aTitle, 0);
                if ( port == 1016 )
                  v6 = &aTabletConnectT;
                else
                  v6 = (const CHAR *)&aTabletConnectT_0;
              }
              else
              {
                v6 = (const CHAR *)&aResetTabletOk;
              }
              MessageBoxA(0, v6, aTitle, 0);
              ExitProcess(0);
            }
            if ( as_mouse == 1 )
            {
              if ( as_emulation == 1 )
                v5 = 90;
              else
                v5 = 111;
            }
            else
            {
              v5 = 75;
            }
          }
          write_data(v5);
          goto LABEL_42;
        }
        v2 = v8 - 1;
      }
      while ( v3 && v8 != 1 );
      if ( choice != -1 )
      {
        v7 = &aTabletIsNotRes;
        goto LABEL_50;
      }
      choice = 0;
      port = 760;
    }
  }
LABEL_4:
  v7 = (const CHAR *)&aParameterError;
LABEL_50:
  MessageBoxA(0, v7, aTitle, 0);
  ExitProcess(1u);
}
// 404000: using guessed type char choice;
// 404002: using guessed type int port;
// 404006: using guessed type char as_mouse;
// 404007: using guessed type char as_emulation;

//----- (0040129E) --------------------------------------------------------
int write_mcr_1011_and_delay()
{
  __outbyte(port + 4, 0xBu);
  return delay_ms(1);
}
// 404002: using guessed type int port;

//----- (004012BB) --------------------------------------------------------
unsigned __int8 read_mcr()
{
  return __inbyte(port + 4);
}
// 404002: using guessed type int port;

//----- (004012CC) --------------------------------------------------------
signed int delay_ms(int a1)
{
  signed int v1; // ebx
  signed int result; // eax

  v1 = GetTickCount() + a1;
  do
    result = GetTickCount();
  while ( v1 < result );
  return result;
}

//----- (004012E4) --------------------------------------------------------
unsigned __int8 write_data(unsigned __int8 a1)
{
  unsigned __int8 v1; // ah
  unsigned __int8 v2; // al
  unsigned __int8 v3; // al
  unsigned __int8 result; // al

  v1 = a1;
  v2 = __inbyte(port + 4);
  do
    v3 = __inbyte(port + 5);
  while ( !(v3 & 0x20) );
  result = v1;
  __outbyte(port, v1);
  return result;
}
// 404002: using guessed type int port;

//----- (00401312) --------------------------------------------------------
char read_data_sp()
{
  char result; // al

  result = read_data();
  if ( result == 83 )
    result = 6;
  return result;
}

//----- (00401345) --------------------------------------------------------
char read_data()
{
  unsigned __int16 v0; // di
  unsigned __int16 v1; // dx
  DWORD v2; // ebx
  unsigned __int8 v3; // al
  DWORD v4; // eax
  int v5; // ecx
  bool v6; // zf
  int v7; // ecx

  v0 = port;
  v2 = GetTickCount();
  while ( 1 )
  {
    v3 = __inbyte(v1);
    if ( v3 & 1 )
      break;
    v4 = GetTickCount();
    v6 = v2 == v4;
    if ( v2 != v4 )
    {
      v2 = v4;
      v7 = v5 - 1;
      if ( !v6 || !v7 )
        return v4;
    }
  }
  v4 = __inbyte(v0);
  return v4;
}
// 404002: using guessed type int port;

//----- (0040137A) --------------------------------------------------------
char set_interrupt()
{
  __int16 v0; // di
  unsigned __int8 v1; // al
  unsigned __int8 v2; // al
  char result; // al

  v0 = port;
  set_baud_rate(0xBu, 12);
  v1 = __inbyte(0x21u);
  if ( port == 760 )
    v2 = v1 & 0xF7;
  else
    v2 = v1 & 0xEF;
  __outbyte(0x21u, v2);
  __outbyte(v0 + 4, 0xBu);
  result = 1;
  __outbyte(v0 + 1, 1u);
  return result;
}
// 404002: using guessed type int port;

//----- (004013C1) --------------------------------------------------------
unsigned __int8 set_baud_rate(unsigned __int8 a1, __int16 a2)
{
  unsigned __int8 result; // al

  __outbyte(port + 3, 0x80u);
  __outbyte(port + 1, HIBYTE(a2));
  __outbyte(port, a2);
  result = a1;
  __outbyte(port + 3, a1);
  return result;
}
// 404002: using guessed type int port;

//----- (004013F1) --------------------------------------------------------
unsigned __int8 do_handshake()
{
  int v0; // eax
  int v1; // eax

  set_baud_rate(2u, 96);
  write_data(0);
  (v0) = 2;
  delay_ms(v0);
  write_data(0x58u);
  (v1) = 4;
  delay_ms(v1);
  return set_baud_rate(0xBu, 12);
}

//----- (00401428) --------------------------------------------------------
char skipws(char *a1)
{
  char result; // al

  while ( 1 )
  {
    result = *a1;
    if ( *a1 == 13 )
      break;
    if ( !result || result != 32 )
      return result;
    ++a1;
  }
  return 0;
}

//----- (00401448) --------------------------------------------------------
void parse_arguments()
{
  char *v0; // ebx
  char v1; // al
  char *v2; // ebx
  char v3; // al

  v0 = (char *)args;
  if ( args == 128 )
  {
    if ( !*(BYTE *)args )
      return;
    v0 = (char *)(args + 1);
  }
  skipws(v0);
  v1 = *v0;
  if ( *v0 == 45 || v1 == 47 )
  {
    v2 = v0 + 1;
    v3 = *v2;
    args = (int)(v2 + 1);
  }
  else
  {
    v1 == 13;
  }
}
// 404008: using guessed type int args;

// ALL OK, 12 function(s) have been successfully decompiled
